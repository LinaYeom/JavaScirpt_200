<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const symbol = Symbol(); // 심볼은 new 로 호출하는게 아니라 함수로 호출해서 생성한다. 
        console.log(symbol)
        const hello = Symbol('hello');
        console.log(hello)
        

        console.log(Number(3) === Number(3)); // Number 은 true
        console.log(Symbol('symbol') === Symbol('symbol')); // Symbol 은 고유한 객체이므로 동일한 값을 가지지 않음. 
        // 심벌은 디버깅 용도이며 고유한 symbol 값만 반환한다.  // 그렇기에 false 이다. 
        console.log(Symbol() === Symbol());
        console.log(typeof Symbol()); // ES6에 추가된 새로운 타입이다. 

        const nationility = Symbol('nationility'); // nationility는 심볼형 타입으로 생성했다. 

        const user = { // user 라는 객체를 생성했다. 
            name: 'jay'
        };
        console.log(user);
        console.log("----------")
        user[nationility] = 'korean'; // 생성한 객체안에 심볼타입으로 선언한'nationility'에 값(korean)을 넣음
        
        console.log(user); // 객체 안에는 name , 'nationility' 이 들어가 있다.
        console.log("user.name: "+ user.name); // 객체안의 속성 
        console.log(nationility); // 이렇게 하면 타입을 불러오는 것이다.
        console.log(user[nationility]);  // 심벌을 객체의 키로 사용 하려면 Symbol 에 대한 래퍼런스를 변수에 담고 있다가 접근할 때 
        // 생성한 객체와 변수를 [] 으로 감싸서 불러온다 
        console.log("----------2")

        for (let key in user) { 
            console.log(key);
        }
        console.log(Object.keys(user)); // name 밖에 안나온다.  //for-in 루프를 통해서 심볼키는 가져올 수 없다. 
        console.log(Object.getOwnPropertyNames(user)); // 그렇기 때문에 object의 키를 반환하는 메서드도 못가지고오고 
        console.log(JSON.stringify(user));  // JSON 키에도 빠지게 된다. 

        const symbolProperties = Object.getOwnPropertySymbols(user); // 심볼 오브젝트 메소드를 통해 해당 객체의 키를 가져와야한다. 
        console.log(symbolProperties); 
        console.log(user[symbolProperties[0]]); // 심볼의 값을 가져옴.. 
    </script>
</body>
</html>